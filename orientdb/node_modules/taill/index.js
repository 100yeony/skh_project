const EventEmitter = require('events');
const fs = require('fs');

const utils = require('./utils');

const emitter = new EventEmitter();

/**
 * A list of files with their absolute path to watch.
 *
 * @type {string[]}
 */
const filespath = [];

/**
 * Store the latest line of each file, used to make lines-diff.
 *
 * @type {number[]}
 */
const filesLastLine = [];

/**
 * Store the interval which is executing the loop.
 *
 * @type {NodeJS.Timer | null}
 */
let interval;

/**
 * Add the path of a file to watch for changes in the `filespath` array.
 * Check if the path redirect to a file and if it isn't already registered.
 * Automatically create the loop if it isn't running.
 * **Note:** automatically transform a relative path to an absolute path.
 *
 * @param {string} filepath - absolute or relative path to the logfile
 * @returns {string | Error} an error or a string which is the filepath
 */
function watchFile(filepath) {
  const absolutePath = utils.getAbsolutePath(filepath);

  /** Check if the path is already registered in our `filespath[]` */
  if (filespath.indexOf(absolutePath) > -1) {
    return new Error(`The filepath ${filepath} is already registered to watch`);
  }

  /** Check if the path redirect to an existing file */
  if (!fs.existsSync(absolutePath)) {
    return new Error(`The filepath ${filepath} doesn't exist`);
  }

  /** If the interval have not been created, we instanciate a loop */
  if (!interval) {
    synchronizeFilesLines();
    createLoop();
  }

  filespath.push(absolutePath);
  filesLastLine.push(-1);

  return filepath;
}

/**
 * Remove the path of a file to watch for changes in the `filespath` array.
 * Check if the path have already been added in the `filespath` array.
 * Return the path of the file to unwatch.
 * **Note:** automatically transform a relative path to an absolute path.
 *
 * @param {string} filepath - absolute or relative path to the logfile
 * @returns {string | Error} an error or a string of the removed filepath
 */
function unwatchFile(filepath) {
  const absolutePath = utils.getAbsolutePath(filepath);
  const filepathIndex = filespath.indexOf(absolutePath);

  /** Check if the absolute path have been added to our `filespath[]` */
  if (filepathIndex === -1) {
    return new Error(`The filepath ${filepath} is not registered, can't unwatched a file not registered`);
  }

  filesLastLine.splice(filepathIndex, 1);
  return utils.getFilename(filespath.splice(filepathIndex, 1).toString());
}

/**
 * This is used to synchronize the latest line of an already existing logfile
 * that have lines written on it.
 */
function synchronizeFilesLines() {
  filespath.forEach((filepath, i) => {
    const log = fs.readFileSync(filepath).toString('utf8').split('\n');

    filesLastLine[i] = log.length - 1;
  });
}

/**
 * Create the loop with a specified pollrate in ms or pre-defined one.
 * Send a `line` event with the content of the line with the filename
 * everytime a new line have been added on the logfile.
 *
 * @param {number} [pollrate] - optional pollrate in ms
 */
function createLoop(pollrate) {
  interval = setInterval(() => {
    filespath.forEach((filepath, i) => {
      // TODO: for performances issues, find a way to read a logfile only if
      // it's stats have been edited (mtime, size, blocks, ...) using `fs.stats`
      const log = fs.readFileSync(filepath).toString('utf8').split('\n');
      const filename = utils.getFilename(filepath);

      if (log.length > filesLastLine[i] + 1) {
        const newLogs = log.slice(filesLastLine[i] + 1, log.length);

        filesLastLine[i] = log.length - 1;
        newLogs.forEach((logLine) => emitter.emit('line', logLine, filename));
      }
    });
  }, pollrate | 250);
}

/**
 * Listen the `EventEmitter` for specific changes.
 *
 * @param {string} event - 'line'
 * @param {any} listener - function to execute when receiving the event
 */
function listenEventEmitter(event, listener) {
  emitter.on(event, listener);
}

/**
 * Remove all listeners for a specific event.
 *
 * @param {string} event - name of the event
 */
function removeEventListeners(event) {
  emitter.removeAllListeners(event);
}

/**
 * Return an array of listeners of a specific event.
 *
 * @param {string} event - name of the event
 */
function getEventListeners(event) {
  return emitter.listeners(event);
}

module.exports = {
  watchFile,
  unwatchFile,
  getEventListeners,
  removeEventListeners,
  synchronizeFilesLines,
  on: listenEventEmitter,
  filesToWatch: filespath,
};
